use std::{env::temp_dir, path::{ PathBuf}, sync::Arc};

use futures::lock::Mutex;
use tarpc::server;
use tokio::net::UnixListener;

mod config;
mod target;
mod sniper;
mod snippet;
mod snippetParser;
mod rifle;
mod handler;
//mod server;
//mod server.rs


#[tokio::main]
async fn main() {
    let socket_path=PathBuf::from("/tmp/sniper.socket");
    let socket = UnixListener::bind(socket_path).unwrap();
    //let config=config::ConfigLoader();
    
    let mut sniper=Arc::new(Mutex::new(sniper::Sniper::new()));
    //sniper.add_target("12345","test.py","python");
    //println!("{:#?}",sniper.rifle.snippets);
    //println!("{:?}",sniper.config.languages["python"]);
    //println!("{:#?}",sniper.snipe("python","if/elif/else"));
    //println!("{:#?}",sniper.snipe("python","if"));
    //sniper.add_target("12345","test.py","python");
    
    //println!("{:?}",config)
    //let config=SniperConfig::new("")
    //println!("Hello, world!");
    let mut listener = tarpc::serde_transport::new()
    .await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = handler::connectionHandler(channel.transport().peer_addr().unwrap());
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
   
}
